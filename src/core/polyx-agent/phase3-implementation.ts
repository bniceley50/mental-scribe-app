/**
 * Phase 3: Implementation
 * 
 * Generates code based on strategy plan with tests and documentation.
 */

import type { TaskSpec, StrategyPlan, Implementation, PhaseResult, AgentConfig } from './types';

export class ImplementationPhase {
  /**
   * Execute implementation generation
   */
  async execute(
    task: TaskSpec, 
    plan: StrategyPlan, 
    config: AgentConfig
  ): Promise<PhaseResult<Implementation>> {
    try {
      const implementation = this.generateImplementation(task, plan, config);
      
      return {
        success: true,
        data: implementation,
        warnings: implementation.criticalReasoningNotes.length === 0
          ? ['No critical reasoning notes provided']
          : undefined
      };
    } catch (error) {
      return {
        success: false,
        errors: [error instanceof Error ? error.message : 'Unknown error in implementation']
      };
    }
  }

  /**
   * Generate implementation code
   */
  private generateImplementation(
    task: TaskSpec, 
    plan: StrategyPlan, 
    config: AgentConfig
  ): Implementation {
    const code = this.generateCode(task, plan);
    const tests = config.mode === 'verified' ? this.generateTests(task, plan) : undefined;
    const documentation = this.generateDocumentation(task, plan);
    const criticalReasoningNotes = this.extractReasoningNotes(task, plan);

    return {
      code,
      tests,
      documentation,
      criticalReasoningNotes
    };
  }

  /**
   * Generate code based on task and plan
   */
  private generateCode(task: TaskSpec, plan: StrategyPlan): string {
    // This is a template generator - in a real implementation,
    // this would use more sophisticated code generation
    const componentCode = plan.components.map(component => {
      return `
/**
 * ${component.description}
 * Complexity: ${component.complexity}
 * Dependencies: ${component.dependencies.join(', ') || 'None'}
 */
function ${this.toCamelCase(component.name)}() {
  // TODO: Implement ${component.name}
  // Edge cases to consider: ${plan.edgeCases.slice(0, 3).join(', ')}
  throw new Error('Not implemented: ${component.name}');
}`;
    }).join('\n\n');

    return `/**
 * Generated implementation for: ${task.description}
 * 
 * This code was generated by PolyX Supreme v1.0
 */

${componentCode}

/**
 * Main entry point
 */
export function execute() {
  // Coordinate component execution
  ${plan.components.map(c => `${this.toCamelCase(c.name)}();`).join('\n  ')}
}
`;
  }

  /**
   * Generate test suite
   */
  private generateTests(task: TaskSpec, plan: StrategyPlan): string {
    const testCases = plan.edgeCases.map((edgeCase, index) => {
      return `
  it('should handle: ${edgeCase}', () => {
    // Arrange
    // TODO: Set up test conditions for ${edgeCase}
    
    // Act
    // TODO: Execute code under test
    
    // Assert
    // TODO: Verify expected behavior
    expect(true).toBe(true); // Placeholder
  });`;
    }).join('\n');

    return `/**
 * Test suite for: ${task.description}
 * 
 * Generated by PolyX Supreme v1.0
 */

import { describe, it, expect } from 'vitest';
import { execute } from './implementation';

describe('${task.description}', () => {
  describe('Core functionality', () => {
    it('should execute successfully', () => {
      // TODO: Implement core functionality test
      expect(true).toBe(true); // Placeholder
    });
  });

  describe('Edge cases', () => {${testCases}
  });

  describe('Error handling', () => {
    it('should handle errors gracefully', () => {
      // TODO: Implement error handling test
      expect(true).toBe(true); // Placeholder
    });
  });
});
`;
  }

  /**
   * Generate documentation
   */
  private generateDocumentation(task: TaskSpec, plan: StrategyPlan): string {
    return `# Implementation Documentation

## Task
${task.description}

## Requirements
${task.requirements?.map(r => `- ${r}`).join('\n') || 'None specified'}

## Constraints
${task.constraints?.map(c => `- ${c}`).join('\n') || 'None specified'}

## Architecture

### Components
${plan.components.map(c => `
#### ${c.name}
- **Description**: ${c.description}
- **Complexity**: ${c.complexity}
- **Dependencies**: ${c.dependencies.join(', ') || 'None'}
`).join('\n')}

## Edge Cases Considered
${plan.edgeCases.map(e => `- ${e}`).join('\n')}

## Potential Failure Points
${plan.failurePoints.map(f => `- ${f}`).join('\n')}

## Usage

\`\`\`typescript
import { execute } from './implementation';

execute();
\`\`\`
`;
  }

  /**
   * Extract critical reasoning notes
   */
  private extractReasoningNotes(task: TaskSpec, plan: StrategyPlan): string[] {
    const notes: string[] = [];

    // Note high-risk areas
    if (plan.failurePoints.length > 3) {
      notes.push(`High risk implementation: ${plan.failurePoints.length} potential failure points identified`);
    }

    // Note complex components
    const complexComponents = plan.components.filter(c => c.complexity === 'high');
    if (complexComponents.length > 0) {
      notes.push(`Complex components require careful implementation: ${complexComponents.map(c => c.name).join(', ')}`);
    }

    // Note edge cases
    if (plan.edgeCases.length > 5) {
      notes.push(`Extensive edge case handling required: ${plan.edgeCases.length} cases identified`);
    }

    // Note dependencies
    const totalDeps = plan.components.reduce((sum, c) => sum + c.dependencies.length, 0);
    if (totalDeps > 3) {
      notes.push(`Complex dependency chain: ${totalDeps} dependencies across components`);
    }

    return notes;
  }

  /**
   * Convert string to camelCase
   */
  private toCamelCase(str: string): string {
    return str
      .replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => {
        return index === 0 ? word.toLowerCase() : word.toUpperCase();
      })
      .replace(/\s+/g, '');
  }
}
